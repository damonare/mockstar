{"version":3,"sources":["../../src/model/MockerParser.js"],"names":["fs","require","fse","path","fsHandler","_","marked","store","gConfig","MockerParser","opts","basePath","matmanMockers","Array","isArray","buildPath","ensureDirSync","db","getDB","join","isReset","mockerList","search","getAll","globs","forEach","item","isDirectory","console","error","relativePath","requirePath","getRequirePath","mockerItem","cacheMockerItem","get","find","name","value","updateConfig","disable","config","activeModule","push","setState","mockServerPath","data","write","mockerName","getAllMocker","filter","route","params","allMockerList","paramsKeyLength","Object","keys","length","matchedArr","mockerConfig","obj","match","routeExtra","routeExtraKeys","routeExtraKeyLength","isExistNotMatchedField","routeExtraKey","sort","a","b","mockModuleName","mocker","getMockerByName","mockModuleList","getMockerByRoute","TARGET_FIELD","mockModuleItem","getMockModuleByName","moduleRelativePath","type","fileName","MOCK_MODULES","moduleFullPath","reqParams","merge","query","updateData","oldMockerItem","newMockerItem","assign","mockerReadMeFile","existsSync","setOptions","renderer","Renderer","gfm","tables","breaks","pedantic","sanitize","smartLists","smartypants","content","readFileSync","replace","e","stack","absolutePath","relative","__dirname","isAbsolute","indexOf","module","exports"],"mappings":"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","file":"MockerParser.js","sourcesContent":["const fs = require('fs');\nconst fse = require('fs-extra');\nconst path = require('path');\nconst fsHandler = require('fs-handler');\nconst _ = require('lodash');\nconst marked = require('marked');\nconst store = require('../store');\n\nconst gConfig = require('../config');\n\nclass MockerParser {\n  /**\n   * 构造函数\n   *\n   * @param {Object} opts 参数\n   * @param {String} opts.basePath mocker的根目录，绝对路径\n   * @param {String} [opts.buildPath] 构建之后的目录，也是数据存储的根目录，绝对路径\n   * @param {Array} [opts.matmanMockers] MatmanMocker 列表\n   */\n  constructor(opts) {\n    this.basePath = opts.basePath;\n    this.matmanMockers = Array.isArray(opts.matmanMockers) ? [...opts.matmanMockers] : [];\n\n    // 只有传递了 opts.buildPath，才处理 db\n    if (opts.buildPath) {\n      // 设置默认值和绝对路径\n      this.buildPath = opts.buildPath;\n\n      // 注意此处一定要保证存储数据的地址是可存在的，否则会保存失败。\n      fse.ensureDirSync(this.buildPath);\n\n      this.db = store.getDB(path.join(this.buildPath, 'db.json'));\n    }\n  }\n\n  /**\n   * 获取所有的 mocker 信息\n   *\n   * @param {Boolean} [isReset] 是否为重置，如果为 true，则将忽略缓存数据\n   * @return {Array}\n   */\n  getAllMocker(isReset) {\n    let mockerList = [];\n\n    // 1. 获取所有的 mocker，约定：this.basePath 的每个子目录都是一个独立的 mocker\n    fsHandler.search.getAll(this.basePath, { globs: ['*'] }).forEach((item) => {\n      // 限制只处理文件夹类型的，不允许在 basePath 目录下有非文件夹的存在\n      if (!item.isDirectory()) {\n        console.error(`${path.join(item.basePath, item.relativePath)} SHOULD BE Directory!`);\n        return;\n      }\n\n      // 模块名字，默认取文件名，\n      // 在根目录下，每个子文件夹就是一个 mocker 单位，其名字即为文件夹名字\n      // let name = path.basename(item.relativePath);\n      // console.log('\\n找到 mocker ：', name, item);\n\n      // 获得 require 这个模块的相对路径\n      let requirePath = getRequirePath(path.join(this.basePath, item.relativePath));\n      // console.log('requirePath ：', requirePath);\n\n      let mockerItem = require(requirePath);\n\n      // 更新用户操作历史记录\n      if (this.db) {\n        // 更新数据\n        let cacheMockerItem = this.db.get('data').find({ name: mockerItem.name }).value();\n\n        // 如果存在记录，则更新两个字段即可\n        if (cacheMockerItem) {\n          mockerItem.updateConfig({\n            disable: cacheMockerItem.config.disable,\n            activeModule: cacheMockerItem.config.activeModule\n          });\n        }\n      }\n\n      mockerList.push(mockerItem);\n    });\n\n    // TODO 2018/6/2 helinjiang: 如果isReset=true，则还需要及时更新到 this.matmanMockers\n    // TODO 2018/6/2 helinjiang: 还要返回 this.matmanMockers 中数据\n\n    if (this.db) {\n      // 存储到本地缓存数据文件内，以便下次启动时能够记录上一次的操作\n      this.db.setState({\n        mockServerPath: this.basePath,\n        buildPath: this.buildPath,\n        data: mockerList\n      }).write();\n    }\n\n    return mockerList;\n  }\n\n  /**\n   * 通过名字获取指定的 mocker\n   *\n   * @param {String} mockerName 名字\n   * @param {Boolean} [isReset] 是否为重置，如果为 true，则将忽略缓存数据\n   * @return {Object} MatmanMocker 对象\n   */\n  getMockerByName(mockerName, isReset) {\n    let mockerList = this.getAllMocker(isReset);\n\n    return mockerList.filter((item) => {\n      return item.name === mockerName;\n    })[0];\n  }\n\n  /**\n   * 通过路由及请求参数获取 mocker 的信息\n   *\n   * @param {String} route 路由规则\n   * @param {Object} [params] 请求的参数\n   * @return {Object}\n   */\n  getMockerByRoute(route, params = {}) {\n    // 为避免 params=null，此处要特别设置一下\n    if (!params) {\n      params = {};\n    }\n\n    const allMockerList = this.getAllMocker();\n\n    const paramsKeyLength = Object.keys(params).length;\n\n    let matchedArr = [];\n\n    allMockerList.forEach((item) => {\n      const mockerConfig = item.config || {};\n\n      // 如果连 route 都没匹配，则无需后续处理\n      if (route !== mockerConfig.route) {\n        return;\n      }\n\n      let obj = {\n        match: 1,\n        data: item\n      };\n\n      let routeExtra = mockerConfig.routeExtra || {},\n        routeExtraKeys = Object.keys(routeExtra),\n        routeExtraKeyLength = routeExtraKeys.length;\n\n      // 如果 routeExtra 为空，则放入数组中之后，无须再后续处理\n      if (!routeExtraKeyLength) {\n        matchedArr.push(obj);\n        return;\n      }\n\n      // 如果 routeExtra 不为空，但请求参数为空，则肯定是匹配失败了的，无须放入数组\n      if (routeExtraKeyLength && !paramsKeyLength) {\n        return;\n      }\n\n      let isExistNotMatchedField = false;\n\n      // 如果 routeExtra 不为空，且请求参数也为空，则为其计算匹配度\n      routeExtraKeys.forEach((routeExtraKey) => {\n        // 注意，这里都转化为字符串来比较\n        if ((routeExtra[routeExtraKey] + '') === (params[routeExtraKey] + '')) {\n          obj.match++;\n        } else {\n          // 如果定义了 routeExtra，就要全匹配，有一个不匹配都不行\n          isExistNotMatchedField = true;\n        }\n      });\n\n      if (!isExistNotMatchedField) {\n        matchedArr.push(obj);\n      }\n    });\n\n    return matchedArr.length ? matchedArr.sort((a, b) => {\n      return b.match - a.match;\n    })[0].data : null;\n  }\n\n  /**\n   * 通过名字获取指定的 mock module\n   *\n   * @param {String} mockerName mocker 名字\n   * @param {String} mockModuleName mock module 名字\n   * @param {Boolean} [isReset] 是否为重置，如果为 true，则将忽略缓存数据\n   * @return {Object} MatmanMockModule 对象\n   */\n  getMockModuleByName(mockerName, mockModuleName, isReset) {\n    let mocker = this.getMockerByName(mockerName, isReset);\n\n    // 有可能找不到 mocker\n    if (!mocker) {\n      console.error('Can not find mock module!', mockerName, mockModuleName);\n      return null;\n    }\n\n    return mocker.mockModuleList.filter((item) => {\n      return item.name === mockModuleName;\n    })[0];\n  }\n\n  /**\n   * 通过路由匹配及请求参数获得响应数据\n   *\n   * @param {String} route 路由规则\n   * @param {Object} [params] 请求的参数\n   * @return {Object}\n   */\n  getResInfoByRoute(route, params = {}) {\n    // 为避免 params=null，此处要特别设置一下\n    if (!params) {\n      params = {};\n    }\n\n    // 1. 获得当前的 mocker 信息\n    let mockerItem = this.getMockerByRoute(route, params);\n\n    if (!mockerItem) {\n      return null;\n    }\n\n    // 2. 获得当前最适合的 mock module\n    // 优先获取 param 中请求的指定 mock_module，其次是 mocker.config.activeModule\n    let mockModuleName = params[gConfig.TARGET_FIELD] || mockerItem.config.activeModule;\n\n    let mockModuleItem = this.getMockModuleByName(mockerItem.name, mockModuleName);\n\n    if (!mockModuleItem) {\n      return null;\n    }\n\n    // 3. 获得 mock module 的绝对路径\n    // 目标模块的路径，需要注意下 no module 的场景\n    const moduleRelativePath = (mockModuleItem.type && mockModuleItem.type === 'noModule') ? mockModuleItem.fileName : path.join(gConfig.MOCK_MODULES, mockModuleName);\n\n    const moduleFullPath = path.join(this.basePath, mockerItem.name, moduleRelativePath);\n\n    // 4. 获得所有的请求参数\n    // 还有部分参数在 mock_module 的 query 字段中，需要合并请求\n    const reqParams = _.merge({}, mockModuleItem.query, params);\n\n    return {\n      mockerItem: mockerItem,\n      mockModuleItem: mockModuleItem,\n      moduleFullPath: moduleFullPath,\n      params: reqParams\n    };\n  }\n\n  /**\n   * 更新 mocker 的 信息\n   *\n   * @param {String} mockerName handler 名字\n   * @param {Object} [updateData] 要更新的数据\n   */\n  updateMocker(mockerName, updateData) {\n    let oldMockerItem = this.getMockerByName(mockerName);\n\n    let newMockerItem = _.merge({}, oldMockerItem, updateData);\n\n    // 更新数据\n    if (this.db) {\n      this.db.get('data')\n        .find({ name: mockerName })\n        .assign(newMockerItem)\n        .write();\n    }\n\n    // 返回新的结果\n    return newMockerItem;\n  }\n\n  /**\n   * 获取指定 mocker 的 README 信息\n   *\n   * @param {String} mockerName\n   */\n  getReadMeContent(mockerName) {\n    let mockerItem = this.getMockerByName(mockerName);\n    if (!mockerItem) {\n      return '异常错误，找不到对应信息！handlerName=' + mockerName;\n    }\n\n    // README.md 的绝对路径\n    let mockerReadMeFile = path.join(mockerItem.basePath, 'README.md');\n    if (!fs.existsSync(mockerReadMeFile)) {\n      return '';\n    }\n\n    marked.setOptions({\n      renderer: new marked.Renderer(),\n      gfm: true,\n      tables: true,\n      breaks: false,\n      pedantic: false,\n      sanitize: false,\n      smartLists: true,\n      smartypants: false\n    });\n\n    try {\n      let content = fs.readFileSync(mockerReadMeFile, 'utf8');\n\n      content = content.replace(/__STATIC_PATH__/g, mockerName + '/static');\n\n      return marked(content);\n    } catch (e) {\n      return e.stack;\n    }\n  }\n}\n\n/**\n * 获得传递给 require 的模块路径，相对于当前文件\n *\n * @param {String} absolutePath 绝对路径\n * @returns {String}\n */\nfunction getRequirePath(absolutePath) {\n  // 获得 require 这个模块的相对路径\n  let relativePath = path.relative(__dirname, absolutePath);\n\n  if (path.isAbsolute(relativePath)) {\n    // 如果 __dirname 和 absolutePath 不在同一个磁盘中，则 path.relative(__dirname, absolutePath) 会返回后者\n    // 因此此处就无需处理相对路径 #128\n  }\n\n  // 注意，path.relative 方法返回的结果中，如果是相对当前目录的，则其会把 './' 去掉，\n  // 例如， './path/a/b' 会被返回 'path/a/b'\n  // 此时如果 require('path/a/b') ，node 会先去 node_modules 模块寻找，\n  // 而不是当前目录去寻找，修改为 require('./path/a/b') 就不会有这样问题，\n  // 因此，这种情况下一定要补上一个 './'，\n  else if (relativePath.indexOf('..') < 0) {\n    relativePath = './' + relativePath;\n  }\n\n  // 需要将“\\”替换为“/”，因为 require 语法中模块的路径是以 \"/\" 来分目录层级的\n  return relativePath.replace(/\\\\/gi, '/');\n}\n\nmodule.exports = MockerParser;"]}